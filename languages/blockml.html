<!doctype html>
<!--

 This page was compiled by ðŸ“œ Scroll, a public domain
 programming language and static site publishing tool.
 
 https://scroll.pub
 
 Generally you don't want to edit it by hand.

 Scroll v34.2.0

-->
<html lang="en-US">
 <head>
  <meta charset="utf-8"></meta>
  <title>blockml - Text markup</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"></meta>
  <meta name="description" content="PLDB: a Programming Language Database. Build the next great programming language."></meta>
  <meta name="generator" content="Scroll v34.2.0"></meta>
  <meta property="og:title" content="blockml"></meta>
  <meta property="og:description" content="blockml is a text markup created in 2014."></meta>
  <meta property="og:image" content=""></meta>
  <meta name="twitter:card" content="summary_large_image"></meta>
</head>
 <body>
  <link rel="stylesheet" type="text/css" href="../scroll.css"></link>
  <link rel="stylesheet" type="text/css" href="../style.css"></link>
  <script src="../libs.js"></script>
  <script src="../search.js"></script>
  <div class="pldbHeader">
   <a href="../index.html" class="logoFont">PLDB</a>
   <form style="display:inline-block;">
    <input type="search" id="headerSearch" placeholder="Search" autocomplete="off"></input>
</form>
   <a href="../lists/top500.html">Languages</a>
   <a href="../lists/features.html">Features</a>
   <a href="../lists/calendar.html">Calendar</a>
   <a href="../docs/csv.html">CSV</a>
   <a href="../lists/lists.html">Lists</a>
   <a href="../posts/index.html">Blog</a>
   <a href="../pages/about.html">About</a>
   <a href="../pages/sponsor-a-fact.html">Sponsor</a>
   <a href="https://build.pldb.com/create">Add Language</a>
</div>
  <a class="gitHubTopRightLinkComponent" href="https://github.com/breck7/pldb"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub icon</title><path d="M12 .297c-6.63 0-12  5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422  18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305  3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0  1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12  3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0  .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a>
  <h1 class="scrollFilePageTitle">
   <a href="blockml.html">blockml</a>
</h1>
  <div class="scrollFilePageComponent" style="column-width:35ch;column-count:2;max-width:90ch;"><h1 class="scrollTitleComponent"><a href="blockml.html">blockml</a></h1>













































<p class="scrollParagraphComponent">blockml is a <a href="../lists/languages.html?filter=textMarkup">text markup</a> created in <a href="../lists/languages.html?filter=2014">2014</a>.</p>

<table class="scrollKpiTable"><tr><td>#592<span><span title="TotalRank: 1104 Jobs: 62 Users: 2193 Facts: 92 Links: 950">on PLDB</span></span></td>
<td>8<span>Years Old</span></td>
<td>0<span><span title="Books about or leveraging blockml">Books</span></span></td></tr>
<tr><td>0<span><span title="Academic publications about or leveraging blockml">Papers</span></span></td></tr>
</table>







<p class="scrollParagraphComponent">BlockML is a lightweight markup language for scientific documents.</p>

<ul class="scrollUnorderedListComponent">
<li>the <a href="http://blockml.awwapps.com">blockml website</a></li>
<li>blockml is developed on <a href="https://github.com/Lindemann/BlockML">GitHub</a> and has 4 stars</li>
<li>blockml first developed in <a href="../lists/originCommunities.html#Aww_Apps">Aww Apps</a></li>
<li>the blockml team is on <a href="https://twitter.com/awwapps">Twitter</a></li>
<li>HTML of this page generated by <a href="https://github.com/breck7/pldb/blob/main/code/LanguagePage.ts">LanguagePage.ts</a></li>
<li><a href="https://build.pldb.com/edit/blockml">Improve our blockml file</a></li>
</ul>

<br>

<div class="exampleCodeHeader">Example from the web:</div>
<code class="scrollCodeBlockComponent">/*
    ____  __           __   __  _____ 
   / __ )/ /___  _____/ /__/  |/  / / 
  / __  / / __ \/ ___/ //_/ /|_/ / /  
 / /_/ / / /_/ / /__/ ,&lt; / /  / / /___
/_____/_/\____/\___/_/|_/_/  /_/_____/

*/


head[

title[Recap of John McCarthy&#39;s Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I]

h3[Judith Lindemann]

h5[Berlin, 25 December 2013]

]

h1[Preface]

This text is originated as an exercise for an university course about scientific writing at the Beuth University of Applied Sciences Berlin. The assignment was to choose a  computer science paper, reproduce the key ideas in own words, and add some own thoughts about that topic as conclusion. 

I have selected the classical paper &quot;b[Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I]&quot; by John McCarthy from 1960 (id[LISP]), because it  permits a fascinating look into the history of programming languages and is the origin of many concepts that are still relevant today.

This text is also influenced by Paul Graham&#39;s article &quot;b[Roots of Lisp]&quot; from 2002 (id[ROOTS]) about that McCarthy paper. I follow Paul Graham&#39;s approach to provide code  examples in actual LISP code instead of m-expressions, and I assume that c[quote] and c[cond] are elementary functions.

toc[Contents]

sec[Introduction][

The paper (id[LISP]) describes a dynamic typed and functional programming language called LISP. The name LISP is an abbreviation for b[LIS]t b[P]rocessor, which is a very  suitable name, because the whole syntax is completely based on a simple list notation for code and data.

LISP was developed in 1958, two years before the paper was published. The main purpose for the development was the lack of appropriate programming languages for artificial  intelligence applications. At this time FORTRAN was the dominant high level programming language, but it was developed for numeric calculations and engineering tasks and  therefore no good fit for AI problems.

LISP was influenced by IPL (Information Processing Language), which was an experimental programming language from 1957 (see id[IPL]). IPL was dedicated to AI research, but also  inappropriate because it was an assembly language. Some of the IPL concepts that LISP had adopted and heavily improved were: list-processing, higher-order functions, recursion  and computation with symbols. Some other concepts were new, for example: conditional control flow, garbage collection, lazy evaluation, and dynamic typing.

At first, we will learn something about the mathematical concepts behind LISP. Then, we will see that the early LISP had only two simple data types. After that, we will define  5-7 elementary functions and we will use them as building blocks to create our own functions. Then, we will see how the memory management works. At the end, we will look, how  LISP was doing in the past 55 years and how LISP is doing today.

]/* Introduction */

sec[Mathematical concepts][

sec[Propositional expressions][
Propositional expressions are expressions whose values are either c[T] &quot;true&quot; or c[F] &quot;false&quot;. These expressions are often combined by connectives like c[Ã¢Ë†Â§] &quot;and&quot;, c[Ã¢Ë†Â¨] &quot;or&quot;  and c[Ã‚Â¬] &quot;not&quot;. Typical examples are:

math[$$x &lt; y$$
$$(x &lt; y) \land (b = c)$$]

]/* Propositional Expressions */

sec[Conditional expressions][
The notation of conditional expressions was a new concept, developed by McCarthy in 1960. It is the ancestor of the &quot;if...then...else&quot; condition, who is part of nearly every  programming language nowadays. Conditional expressions allow a recursive definition of functions in a convenient way. A conditional expression has the form:

math[$$(p_1 \rightarrow e_1,\cdots,p_n \rightarrow e_n)$$]

The b[p]Ã¢â‚¬â„¢s are propositional expressions that are true or false. The b[e]Ã¢â‚¬â„¢s could be any kind of expression. One could read &quot;if b[p]sub[1] then b[e]sub[1], else if b[p] sub[2] then b[e]sub[2], ..., else if b[p]sub[n] then b[e]sub[n]&quot; or &quot;b[p]sub[1] yields b[e]sub[1], ..., b[p]sub[n] yields b[e]sub[n]&quot;.

The b[p]Ã¢â‚¬â„¢s get evaluate from left to right. When the first true b[p] is found, then the conditional expressions returns the b[e] that belongs to the b[p].

math[$$(1 &lt; 2 \rightarrow 4, 1 &gt; 2 \rightarrow 3) = 4$$

$$(2 &lt; 1 \rightarrow 4, 2 &gt; 1 \rightarrow 3, 2 &gt; 1 \rightarrow 2) = 3$$

$$(2 &lt; 1 \rightarrow 4, T \rightarrow 3) = 3$$

$$(2 &lt; 1 \rightarrow {0 \over 0}, T \rightarrow 3) = 3$$]

The whole conditional expressions is undefined:
ol[
- if all b[p]&#39;s are false, 
- if an undefined b[p] occurs before a true b[p] occurs 
- or if the b[e] that belongs to the first true b[p] is undefined it self
]

math[$$(2 &lt; 1 \rightarrow 3, 4 &lt; 1 \rightarrow 4) \mbox{ is undefined}$$

$$({0 \over 0} &lt; 1 \rightarrow 3, 1 &lt; 4 \rightarrow 4) \mbox{ is undefined}$$

$$(2 &lt; 1 \rightarrow 3, T \rightarrow {0 \over 0} )\mbox{ is undefined}$$]

][COND]/* Conditional expressions */

sec[Recursive function definitions][

With the help of conditional expressions it is easy to define recursive functions. The factorial of a non-negative integer b[n] could be described as follows:

math[$$n! = (n = 0 \rightarrow 1, T \rightarrow n \cdot(n - 1)!)$$]

The evaluation of 0! returns 1. The evaluation of 2! looks as follows:

math[\\begin{eqnarray*}
2! &amp;=&amp; (2 = 0 \\rightarrow 1, T \\rightarrow 2 \\cdot (2 - 1)!)\\\\
&amp;=&amp; 2 \\cdot 1!\\\\
&amp;=&amp; 2 \\cdot (1 = 0 \\rightarrow 1 T \\rightarrow \\cdot (1 - 1)!)\\\\
&amp;=&amp; 2 \\cdot 1 \\cdot 0!\\\\
&amp;=&amp; 2 \\cdot 1 \\cdot (0 = 0 \\rightarrow 1, T \\rightarrow 0\\cdot(0-1)!)\\\\
&amp;=&amp;2\\cdot1\\cdot1\\\\
&amp;=&amp;2
\\end{eqnarray*}]

]/* Recursive function definitions */

sec[Lambda calculus][
The Lambda calculus is a formal notation, which is used in LISP to generate new functions and to use functions as arguments. It was introduced by Alonzo Church in 1941 (see id[ LAMBDA]).

Church distinguishes between forms and functions. An expression like im[$y^2 + x$] is a form. An expression like im[$f(3, 4)$ ] a function. im[$y^2 + x$] is not a function  because the expression im[$y^2 + x(3, 4)$] does not determine and could turn into 19 or 13. The problem is that the order, in which the arguments 3 and 4 are inserted into the  form, is undefined. To convert a form into a function we can write: is $2.50 for the first one, and $2.00 for each additional one

math[$$\lambda((x_1, \cdots, x_n),\cal E)$$]

im[$\cal E$] is a form and im[$x_1, \cdots, x_n$] are the ordered parameters for im[$\cal E$]. The ÃŽÂ»-expression is a function because the variables in im[$\cal E$] can be  substituted with arguments in the order of the parameter list im[$x_1, \cdots, x_n$]. We say that the variables of a ÃŽÂ»-expression are bounded. The example from above looks now  like this:

math[$$\lambda((x,y),y^2 +x)$$]

And with arguments like this:

math[$$\lambda((x,y),y^2 +x)(3,4) = 19$$]


If we want to define a recursive function like

math[$${\rm sqrt}(a,x,\epsilon)
        = (|x^2 - a| &lt; \epsilon \rightarrow x, T \rightarrow {\rm sqrt}(a,
{1 \over 2}(x + {a \over x}),\epsilon))$$]

in lambda notation

math[$${\rm sqrt} = \lambda((a,x,\epsilon),(|x^2 - a| &lt; \epsilon \rightarrow x,
T\rightarrow
{\rm sqrt} (a,{1 \over 2}(x + {a \over x}), \epsilon))),$$]

we found that these definition is inadequate, because the right-hand side im[$sqrt$] can not serve as an expression for the whole function. Remember, a function would look like  im[$sqrt(a,x,ÃŽÂµ)$].

In order to define recursive ÃŽÂ»-expressions, we must introduce a new notation.

math[$$label(f,\cal E)$$]

b[f] can be seen as the function name. The occurrence of b[f] within im[$\cal E$] will be evaluated to the label-expression as if b[f] is a parameter of the function. 

math[$$label(sqrt, \lambda((a,x,\epsilon),(| x^2 - a|
&lt; \epsilon \rightarrow x, T \rightarrow {\rm sqrt} (a, {1 \over 2}(x + {a
\over x}),\epsilon))))$$]

][LAMBDACALCULUS]/* Lambda calculus */

]/* Mathematical concepts behind Lisp */</code>





</div><div class="scrollFilePageComponent" style="column-width:70ch;column-count:1;max-width:90ch;">
<h4 class="scrollSubsectionComponent">Language <a href="../lists/features.html">features</a></h4>

<table class="scrollTableComponent"><thead><tr><th>Feature</th>

<th>Supported</th>

<th>Example</th>

<th>Token</th>
</tr></thead>
<tbody><tr><td><a href="../languages/booleans-feature.html">Booleans</a></td>
<td>âœ“</td>
<td></td>
<td>true false</td>
</tr>
<tr><td><a href="../languages/comment-feature.html">Comments</a></td>
<td>âœ“</td>
<td><pre>/* A comment
*/</pre></td>
<td></td>
</tr>
<tr><td><a href="../languages/multiline-comments-feature.html">MultiLine Comments</a></td>
<td>âœ“</td>
<td><pre>/* A comment
*/</pre></td>
<td>/* */</td>
</tr>
<tr><td><a href="../languages/semantic-indentation-feature.html">Semantic Indentation</a></td>
<td>Ï´</td>
<td></td>
<td></td>
</tr></tbody></table>











<h4 class="scrollSubsectionComponent">HackerNews discussions of blockml</h4>

<table class="scrollTableComponent"><thead><tr><th>title</th>

<th>date</th>

<th>score</th>

<th>comments</th>
</tr></thead>
<tbody><tr><td><a href="https://news.ycombinator.com/item?id=7698827">Show HN: BlockML â€“ A markup language for scientific documents</a></td>
<td>05/05/2014</td>
<td>3</td>
<td>0</td>
</tr></tbody></table>

<div class="scrollKeyboardNav"><a href="concise-encoding.html">concise-encoding.html</a> Â· blockml.html Â· <a href="blitzplus.html">blitzplus.html</a><script>document.addEventListener('keydown', function(event) {
  if (document.activeElement !== document.body) return
  const getLinks = () => document.getElementsByClassName("scrollKeyboardNav")[0].getElementsByTagName("a")
  if (event.key === "ArrowLeft")
    getLinks()[0].click()
  else if (event.key === "ArrowRight")
    getLinks()[1].click()
 });</script></div>
<p class="scrollFileViewSourceUrlComponent"><a href="https://github.com/breck7/pldb/blob/main/database/things/blockml.pldb">View source</a></p></div>
  <div class="pldbFooter">
   <a href="../index.html" class="logoFont">PLDB</a>
   <span>- Build the next great programming language Â· <a title="This page was built in 2022 from commit 5ecc5b805d2eb0265ac43250f5ca3e304a565859" href="https://github.com/breck7/pldb/commit/5ecc5b805d2eb0265ac43250f5ca3e304a565859">v2022</a> Â· </span>
   <a href="../pages/about.html">Day 37</a>
   <span>Â·</span>
   <a href="../docs/csv.html">Docs</a>
   <span>Â·</span>
   <a href="https://build.pldb.com">Build</a>
   <span>Â·</span>
   <a href="../pages/acknowledgements.html">Acknowledgements</a>
   <span>Â·</span>
   <a href="https://pldb.com/nginxDaily.html">Traffic Today</a>
   <span>Â·</span>
   <a href="https://pldb.com/nginxDailyAll.html">Traffic Trends</a>
   <span>Â·</span>
   <a href="../pages/mirrors.html">Mirrors</a>
   <span>Â·</span>
   <a href="https://github.com/breck7/pldb">GitHub</a>
   <span>Â·</span>
   <a href="mailto:feedback@pldb.com">feedback@pldb.com</a>
</div>
</body>
</html>
