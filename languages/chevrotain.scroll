title chevrotain

import settings.scroll
htmlTitle chevrotain - Library

viewSourceUrl https://github.com/breck7/pldb/blob/main/database/things/chevrotain.pldb

paragraph
 chevrotain is a <a href="../lists/languages.html?filter=library">library</a> created in <a href="../lists/languages.html?filter=2015">2015</a>.

kpiTable
 #346 on PLDB
 7 Years Old
 2.5k <span title="Crude user estimate from a linear model.">Users</span>







paragraph
 Parser Building Toolkit for JavaScript

list
 - the <a href="http://sap.github.io/chevrotain/">chevrotain website</a>
 - chevrotain is developed on <a href="https://github.com/SAP/chevrotain">GitHub</a> and has 1,957 stars
 - chevrotain first developed in <a href="../lists/originCommunities.html#SAP">SAP</a>
 - HTML of this page generated by <a href="https://github.com/breck7/pldb/blob/main/code/LanguagePage.ts">LanguagePage.ts</a>
 - <a href="https://build.pldb.com/edit/chevrotain">Improve our chevrotain file</a>

html
 <br>

exampleCodeHeader Example from the web:
code
 &quot;use strict&quot;
 /**
  * An Example of implementing a CSV Grammar with Chevrotain.
  *
  * Based on: https://github.com/antlr/grammars-v4/blob/master/csv/CSV.g4
  *
  * Note that this is a pure grammar without any actions (either embedded or via a CST Visitor).
  */
 const { createToken, Lexer, Parser, EMPTY_ALT } = require(&quot;chevrotain&quot;)
 
 // ----------------- lexer -----------------
 const Text = createToken({ name: &quot;Text&quot;, pattern: /[^,\n\r&quot;]+/ })
 const Comma = createToken({ name: &quot;Comma&quot;, pattern: /,/ })
 const NewLine = createToken({
     name: &quot;NewLine&quot;,
     pattern: /\r?\n/
 })
 const String = createToken({ name: &quot;String&quot;, pattern: /&quot;(?:&quot;&quot;|[^&quot;])*&quot;/ })
 
 const allTokens = [Text, String, Comma, NewLine]
 const CsvLexer = new Lexer(allTokens)
 
 // Parser
 class CsvParser extends Parser {
     constructor() {
         super(allTokens)
 
         // not mandatory, using $ (or any other sign) to reduce verbosity
         const $ = this
 
         $.RULE(&quot;csvFile&quot;, () =&gt; {
             $.SUBRULE($.hdr)
             $.AT_LEAST_ONE(() =&gt; {
                 $.SUBRULE2($.row)
             })
         })
 
         $.RULE(&quot;hdr&quot;, () =&gt; {
             $.SUBRULE($.row)
         })
 
         $.RULE(&quot;row&quot;, () =&gt; {
             $.SUBRULE($.field)
             $.MANY(() =&gt; {
                 $.CONSUME(Comma)
                 $.SUBRULE2($.field)
             })
             $.CONSUME(NewLine)
         })
 
         $.RULE(&quot;field&quot;, () =&gt; {
             $.OR([
                 { ALT: () =&gt; $.CONSUME(Text) },
                 { ALT: () =&gt; $.CONSUME(String) },
                 { ALT: EMPTY_ALT(&quot;empty field&quot;) }
             ])
         })
 
         // very important to call this after all the rules have been defined.
         // otherwise the parser may not work correctly as it will lack information
         // derived during the self analysis phase.
         this.performSelfAnalysis()
     }
 }
 
 // wrapping it all together
 // reuse the same parser instance.
 const parser = new CsvParser([])
 
 module.exports = function(text) {
     // 1. Tokenize the input.
     const lexResult = CsvLexer.tokenize(text)
 
     // 2. Set the Parser&#39;s input
     parser.input = lexResult.tokens
 
     // 3. invoke the desired parser rule
     const cst = parser.csvFile()
 
     return {
         cst: cst,
         lexResult: lexResult,
         parseErrors: parser.errors
     }
 }



















keyboardNav ini.html dafny.html
