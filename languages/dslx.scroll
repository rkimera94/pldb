title dslx

import settings.scroll
htmlTitle dslx - Programming language

viewSourceUrl https://github.com/breck7/pldb/blob/main/database/things/dslx.pldb

* dslx is a <a href="../lists/languages.html?filter=pl">programming language</a> created in 2020.
 link ../lists/languages.html?filter=2020 2020

 

kpiTable
 #1039 <span title="TotalRank: 1582 Jobs: 101 Users: 2742 Facts: 528 Links: 953">on PLDB</span>
 2 Years Old
 0 <span title="Books about or leveraging dslx">Books</span>
 0 <span title="Academic publications about or leveraging dslx">Papers</span>

* DSLX is a domain specific, functional language to build hardware that can also run effectively as host software. The DSL targets the XLS compiler (by conversion to XLS IR) to enable flows for FPGAs and ASICs (note that other frontends will become available in the future). DSLX mimics Rust, while being an immutable expression-based dataflow DSL with hardware-oriented features; e.g. arbitrary bitwidths, entirely fixed size objects, fully analyzeable call graph, etc. To avoid arbitrary new syntax/semantics choices the DSL mimics Rust where it is reasonably possible; for example, integer conversions all follow the same semantics as Rust.

- dslx first developed in <a href="../lists/originCommunities.html#Google">Google</a>
- Read more about dslx on the web: <a href="https://google.github.io/xls/dslx_reference/">1</a>
- HTML of this page generated by <a href="https://github.com/breck7/pldb/blob/main/code/LanguagePage.ts">LanguagePage.ts</a>
- <a href="https://build.pldb.com/edit/dslx">Improve our dslx file</a>

html
 <br>

exampleCodeHeader Example from the web:
code
 fn cast_to_array(x: u6) -&gt; u2[3] {
   x as u2[3]
 }
 
 fn cast_from_array(a: u2[3]) -&gt; u6 {
   a as u6
 }
 
 fn concat_arrays(a: u2[3], b: u2[3]) -&gt; u2[6] {
   a ++ b
 }
 
 test cast_to_array {
   let a_value: u6 = u6:0b011011;
   let a: u2[3] = cast_to_array(a_value);
   let a_array = u2[3]:[1, 2, 3];
   let _ = assert_eq(a, a_array);
   // Note: converting back from array to bits gives the original value.
   let _ = assert_eq(a_value, cast_from_array(a));
 
   let b_value: u6 = u6:0b111001;
   let b_array: u2[3] = u2[3]:[3, 2, 1];
   let b: u2[3] = cast_to_array(b_value);
   let _ = assert_eq(b, b_array);
   let _ = assert_eq(b_value, cast_from_array(b));
 
   // Concatenation of bits is analogous to concatenation of their converted
   // arrays. That is:
   //
   //  convert(concat(a, b)) == concat(convert(a), convert(b))
   let concat_value: u12 = a_value ++ b_value;
   let concat_array: u2[6] = concat_value as u2[6];
   let _ = assert_eq(concat_array, concat_arrays(a_array, b_array));
 
   // Show a few classic &quot;endianness&quot; example using 8-bit array values.
   let x = u32:0xdeadbeef;
   let _ = assert_eq(x as u8[4], u8[4]:[0xde, 0xad, 0xbe, 0xef]);
   let y = u16:0xbeef;
   let _ = assert_eq(y as u8[2], u8[2]:[0xbe, 0xef]);
 
   ()
 }

foldBreak
## Language <a href="../lists/features.html">features</a>

treeTable
 row
  Feature Comments
  FeatureLink ../languages/comment-feature.html
  Supported ✓
  Example
   // A comment
  Token 
 row
  Feature Line Comments
  FeatureLink ../languages/line-comments-feature.html
  Supported ✓
  Example
   // A comment
  Token //
 row
  Feature Semantic Indentation
  FeatureLink ../languages/semantic-indentation-feature.html
  Supported ϴ
  Example
  Token 

keyboardNav q-sharp.html catala.html
