title Modula-2

import settings.scroll
htmlTitle Modula-2 - Pl

viewSourceUrl https://github.com/breck7/pldb/blob/main/database/things/modula-2.pldb

paragraph
 Modula-2 is a <a href="../lists/languages.html?filter=pl">pl</a> created in <a href="../lists/languages.html?filter=1978">1978</a> by <a href="../lists/creators.html#Niklaus_Wirth">Niklaus Wirth</a>.

kpiTable
 #47 <span title="TotalRank: 150 Jobs: 65 Users: 621 Facts: 10 Links: 75">on PLDB</span>
 44 Years Old
 655 <span title="Crude user estimate from a linear model.">Users</span>
 1 <span title="Books about or leveraging Modula-2">Books</span>
 0 <span title="Academic publications about or leveraging Modula-2">Papers</span>
 306 <span title="Modula-2 repos on GitHub.">Repos</span>







paragraph
 Modula-2 is a computer programming language designed and developed between 1977 and 1985 by Niklaus Wirth at the Swiss Federal Institute of Technology in Zurich (ETH Zurich) as a revision of Pascal to serve as the sole programming language for the operating system and application software for the personal workstation Lilith. The principal concepts were: The module as a compilation unit for separate compilation The coroutine as the basic building block for concurrent processes Types and procedures that allow access to machine-specific data. Modula-2 was viewed by Niklaus Wirth as a successor to his earlier programming languages Pascal and Modula. <a href="https://en.wikipedia.org/wiki/Modula-2">Read more on Wikipedia...</a>

list
 - the <a href="https://en.wikipedia.org/wiki/Modula-2">Modula-2 Wikipedia page</a>
 - There are at least 306 Modula-2 repos on <a href="https://github.com/search?q=language:Modula-2">GitHub</a>
 - file extensions for Modula-2 include mod, m2, def, MOD, DEF, mi and md
 - The  Google BigQuery Public Dataset GitHub snapshot shows 103 users using Modula-2 in 115 repos on <a href="https://api.github.com/search/repositories?q=language:Modula-2">GitHub</a>
 - Explore Modula-2 snippets on <a href="http://www.rosettacode.org/wiki/Category:Modula-2">Rosetta Code</a>
 - Modula-2 is supported by the <a href="https://www.sourceware.org/gdb/">GDB</a>
 - Modula-2 is listed on <a href="https://hopl.info/showlanguage.prx?exp=817">HOPL</a>
 - Modula-2 appears in the <a href="https://www.tiobe.com/tiobe-index/">TIOBE Index</a>
 - <a href="languages/pygments.html">Pygments</a> supports <a href="https://github.com/pygments/pygments/blob/master/pygments/lexers/modula2.py">syntax highlighting</a> for Modula-2
 - GitHub supports <a href="https://github.com/harogaston/Sublime-Modula-2" title="The package used for syntax highlighting by GitHub Linguist.">syntax highlighting</a> for Modula-2
 - See also: (10 related languages)<a href="modula.html">Modula</a>, <a href="mesa.html">Mesa</a>, <a href="pascal.html">Pascal</a>, <a href="modula-3.html">Modula-3</a>, <a href="oberon.html">Oberon</a>, <a href="ada.html">Ada</a>, <a href="lua.html">Lua</a>, <a href="seed7.html">Seed7</a>, <a href="zonnon.html">Zonnon</a>, <a href="isbn.html">ISBN</a>
 - HTML of this page generated by <a href="https://github.com/breck7/pldb/blob/main/code/LanguagePage.ts">LanguagePage.ts</a>
 - <a href="https://build.pldb.com/edit/modula-2">Improve our Modula-2 file</a>

html
 <br>

exampleCodeHeader Example from <a href='https://github.com/leachim6/hello-world/blob/main/m/Modula 2.mod'>hello-world</a>:
code
 MODULE HelloWorld;
 
 FROM Terminal2 IMPORT WriteString, WriteLn;
 
 BEGIN
 
     WriteString(&quot;Hello World&quot;);
     WriteLn;
     
 END HelloWorld.

exampleCodeHeader Example from <a href='http://helloworldcollection.de/#Modula-2'>the Hello World Collection</a>:
code
 (* Hello World in Modula-2 *)
 
 MODULE HelloWorld;
 FROM InOut IMPORT WriteString,WriteLn;
 BEGIN
   WriteString(&quot;Hello World!&quot;);
   WriteLn;
 END HelloWorld.
 

exampleCodeHeader Example from <a href='https://github.com/harogaston/Sublime-Modula-2'>Linguist</a>:
code
 IMPLEMENTATION MODULE HuffChan;
 
 (*
  This module shows how to redefine standard IO file functions. It provides
  functions for reading and writing packed files opened in Raw mode.
 *)
 
 IMPORT IOChan, IOLink, ChanConsts, IOConsts, SYSTEM, Strings;
 FROM Storage IMPORT ALLOCATE, DEALLOCATE;
 
 CONST
   rbldFrq = 512;	(* means: every 512 bytes rebuild table *)
 
 TYPE
   charTap  = POINTER TO ARRAY [0..MAX(INTEGER)-1] OF CHAR;
   smbTp = POINTER TO smbT;
 
   smbT = RECORD			(* Huffman&#39;s tree *)
     ch			: CHAR;
     n			: CARDINAL; (* frequncy of char ch *)
     left,right,next	: smbTp;
   END;
 
   tblT = RECORD		(* bit sequence for code *)
     vl		: CARDINAL;	(* bit sequence *)
     cnt		: INTEGER;	(* it length *)
   END;
 
   lclDataT = RECORD	(* channel&#39;s local data *)
     tRoot 	: smbTp;
     htbl	: ARRAY [0..255] OF tblT;     (* code -&gt; bit sequence table *)
     ftbl  	: ARRAY [0..255] OF CARDINAL; (* frequncey table *)
     wBf,rb1,rb2	: CARDINAL;
     wbc,rbc,smc	: INTEGER;
     chid	: IOChan.ChanId;
   END;
   lclDataTp = POINTER TO lclDataT;
   charp     = POINTER TO CHAR;
 
 VAR
   did	: IOLink.DeviceId;
   ldt	: lclDataTp;
 
 
 PROCEDURE Shf(a:CARDINAL; b : INTEGER) : CARDINAL; (* shl a,b (or shr) *)
 BEGIN
   RETURN SYSTEM.CAST(CARDINAL,SYSTEM.SHIFT(SYSTEM.CAST(BITSET,a),b));
 END Shf;
 
 PROCEDURE wrDword(a:CARDINAL);	(* write 4 bytes to file *)
 BEGIN
   IOChan.RawWrite(ldt^.chid,SYSTEM.ADR(a),4);
 END wrDword;
 
 PROCEDURE rdDword() : CARDINAL;  (* read 4 bytes from file *)
 VAR
   a,z : CARDINAL;
 BEGIN
   a:=0;
   IOChan.RawRead(ldt^.chid,SYSTEM.ADR(a),4,z);
   RETURN a;
 END rdDword;
 
 PROCEDURE wrSmb(ch : CHAR);	(* write bit sequence for code ch *)
 VAR
   v,h : CARDINAL;
   b,c : INTEGER;
 BEGIN
   WITH ldt^ DO
     v:=htbl[ORD(ch)].vl;
     c:=htbl[ORD(ch)].cnt;
     IF c+wbc&lt;=32 THEN
       wBf:=Shf(wBf,c);
       wBf:=wBf+v;
       wbc:=wbc+c;
       IF wbc=32 THEN
 	wrDword(wBf);
 	wBf:=0; wbc:=0;
       END;
       RETURN;
     END;
     b:=c+wbc-32;
     h:=Shf(v,-b);
     wBf:=Shf(wBf,32-wbc)+h;
     wrDword(wBf);
     wBf:=v-Shf(h,b);
     wbc:=b;
   END;
 END wrSmb;
 
 PROCEDURE flush();	(* write data in buffer *)
 BEGIN
   WITH ldt^ DO
     wBf:=Shf(wBf,32-wbc);
     wrDword(wBf);
   END;
 END flush;
 
 PROCEDURE getSym() : CHAR; (* find code for first bit sequence in buffer *)
 VAR
   t,i : CARDINAL;
   b   : INTEGER;
 BEGIN
   WITH ldt^ DO
     IF rbc&lt;=32 THEN
       rb2:=rdDword();
       t:=Shf(rb2,-rbc);
       IF rbc=32 THEN t:=0; END;
       rb1:=rb1+t;
       rb2:=Shf(rb2,32-rbc);
       IF rbc=0 THEN rb2:=0; END;
       rbc:=rbc+32;
     END;
     FOR i:=0 TO 255 DO
       t:=Shf(rb1,htbl[i].cnt-32);
       IF t=htbl[i].vl THEN
 	rb1:=Shf(rb1,htbl[i].cnt);
 	b:=32-htbl[i].cnt;
 	t:=Shf(rb2,-b);
 	rb1:=rb1+t;
 	rb2:=Shf(rb2,32-b);
 	rbc:=rbc+b-32;
 	RETURN CHR(i);
       END;
     END;
   END;
 END getSym;
 
 PROCEDURE Insert(s : smbTp); (* insert new character in Huffman&#39;s tree *)
 VAR
   cr : smbTp;
 BEGIN
   WITH ldt^ DO
     IF tRoot=NIL THEN
       cr:=tRoot;
       tRoot:=s;
       s^.next:=cr;
       RETURN;
     ELSIF tRoot^.n&lt;=s^.n THEN
       cr:=tRoot;
       tRoot:=s;
       s^.next:=cr;
       RETURN;
     END;
     cr:=tRoot;
     WHILE (cr^.next&lt;&gt;NIL) &amp; (cr^.next^.n&gt;s^.n) DO
       cr:=cr^.next;
     END;
     s^.next:=cr^.next;
     cr^.next:=s;
   END;
 END Insert;
 
 PROCEDURE BuildTree(); (* build Huffman&#39;s tree *)
 VAR
   cr,ocr,ncr : smbTp;
 BEGIN
   WITH ldt^ DO
     LOOP
       ocr:=NIL; cr:=tRoot;
       WHILE cr^.next^.next&lt;&gt;NIL  DO
 	ocr:=cr; cr:=cr^.next;
       END;
       NEW(ncr);
       ncr^.n:=cr^.n+cr^.next^.n;
       ncr^.left:=cr;
       ncr^.right:=cr^.next;
       IF ocr&lt;&gt;NIL THEN
 	ocr^.next:=NIL;
 	Insert(ncr);
       ELSE
 	tRoot:=NIL;
 	Insert(ncr);
 	EXIT;
       END;
     END;
   END;
 END BuildTree;
 
 PROCEDURE BuildTable(cr: smbTp; vl,n: CARDINAL); (* build table: code -&gt; bit sequence *)
 BEGIN
   WITH ldt^ DO
     IF cr^.left=NIL THEN
       htbl[ORD(cr^.ch)].vl:=vl;
       htbl[ORD(cr^.ch)].cnt:=n;
       DISPOSE(cr);
       RETURN;
     END;
     vl:=vl*2;
     BuildTable(cr^.left,vl,n+1);
     BuildTable(cr^.right,vl+1,n+1);
     DISPOSE(cr);
   END;
 END BuildTable;
 
 PROCEDURE clcTab(); (* build code/bitseq. table from frequency table *)
 VAR
   i : CARDINAL;
   s : smbTp;
 BEGIN
   WITH ldt^ DO
     tRoot:=NIL;
     FOR i:=0 TO 255 DO
       NEW(s);
       s^.ch:=CHR(i);
       s^.n:=ftbl[i];
       s^.left:=NIL; s^.right:=NIL; s^.next:=NIL;
       Insert(s);
     END;
     BuildTree();
     BuildTable(tRoot,0,0);
   END;
 END clcTab;
 
 PROCEDURE iniHuf();
 VAR
   i : CARDINAL;
 BEGIN
   WITH ldt^ DO
     FOR i:=0 TO 255 DO
       ftbl[i]:=1;
     END;
     wBf:=0; wbc:=0; rb1:=0; rb2:=0; rbc:=0;
     smc:=0;
     clcTab();
   END;
 END iniHuf;
 
 
 PROCEDURE RawWrite(x: IOLink.DeviceTablePtr; buf: SYSTEM.ADDRESS;
 		len: CARDINAL);
 VAR
   i	: CARDINAL;
   ch	: CHAR;
   cht	: charTap;
 BEGIN
   IF len = 0 THEN RETURN; END;
   ldt:=SYSTEM.CAST(lclDataTp,x^.cd);
   cht:=SYSTEM.CAST(charTap,buf);
   WITH ldt^ DO
     FOR i:=0 TO len-1 DO
       ch:=cht^[i];
       wrSmb(ch);
       IF ch = 377C THEN wrSmb(ch); END;
       ftbl[ORD(ch)]:=ftbl[ORD(ch)]+1; smc:=smc+1;
       IF smc=rbldFrq THEN
 	clcTab();
 	smc:=0;
       END;
     END;
   END;
   x^.result:=IOChan.ReadResult(ldt^.chid);
 END RawWrite;
 
 PROCEDURE RawRead(x: IOLink.DeviceTablePtr; buf: SYSTEM.ADDRESS;
 		blen: CARDINAL; VAR len: CARDINAL);
 VAR
   i	: CARDINAL;
   cht	: charTap;
   ch	: CHAR;
 BEGIN
   ldt:=SYSTEM.CAST(lclDataTp,x^.cd);
   cht:=SYSTEM.CAST(charTap,buf);
   IF (blen=0) OR (x^.result&lt;&gt;IOConsts.allRight) THEN len:=0; RETURN; END;
   WITH ldt^ DO
     FOR i:=0 TO blen-1 DO
       ch:=getSym();
       IF ch = 377C THEN
 	ch:=getSym();
 	IF ch = 0C THEN
 	  x^.result:=IOConsts.endOfInput;
 	  len:=i; cht^[i]:=0C;
 	  RETURN;
 	END;
       END;
       cht^[i]:=ch;
       ftbl[ORD(ch)]:=ftbl[ORD(ch)]+1; smc:=smc+1;
       IF smc=rbldFrq THEN
 	clcTab();
 	smc:=0;
       END;
     END;
     len:=blen;
   END;
 END RawRead;
 
 PROCEDURE CreateAlias(VAR cid: ChanId; io: ChanId; VAR res: OpenResults);
 VAR
   x	: IOLink.DeviceTablePtr;
 BEGIN
   IOLink.MakeChan(did,cid);
   IF cid = IOChan.InvalidChan() THEN
     res:=ChanConsts.outOfChans
   ELSE
     NEW(ldt);
     IF ldt=NIL THEN
       IOLink.UnMakeChan(did,cid);
       res:=ChanConsts.outOfChans;
       RETURN;
     END;
     x:=IOLink.DeviceTablePtrValue(cid,did,IOChan.notAvailable,&quot;&quot;);
     ldt^.chid:=io;
     x^.cd:=ldt;
     x^.doRawWrite:=RawWrite;
     x^.doRawRead:=RawRead;
     res:=ChanConsts.opened;
     iniHuf();
     x^.result:=IOConsts.allRight;
   END;
 END CreateAlias;
 
 PROCEDURE DeleteAlias(VAR cid: ChanId);
 VAR
   x	: IOLink.DeviceTablePtr;
 BEGIN
   x:=IOLink.DeviceTablePtrValue(cid,did,IOChan.notAvailable,&quot;&quot;);
   ldt:=x^.cd;
   IF ldt^.rbc=0 THEN
     wrSmb(377C);
     wrSmb(0C);
     flush();
   END;
   DISPOSE(ldt);
   IOLink.UnMakeChan(did,cid);
 END DeleteAlias;
 
 BEGIN
   IOLink.AllocateDeviceId(did);
 END HuffChan.
 

exampleCodeHeader Example from <a href='https://en.wikipedia.org/wiki/Modula-2'>Wikipedia</a>:
code
 ABS         EXCL            LONGINT    REAL
 BITSET      FALSE           LONGREAL   SIZE
 BOOLEAN     FLOAT           MAX        TRUE
 CAP         HALT            MIN        TRUNC
 CARDINAL    HIGH            NIL        VAL
 CHAR        INC             ODD
 CHR         INCL            ORD
 DEC         INTEGER         PROC





foldBreak
subsection Language <a href="../lists/features.html">features</a>

treeTable
 row
  Feature Booleans
  FeatureLink ../languages/booleans-feature.html
  Supported ✓
  Example
  Token TRUE FALSE
 row
  Feature Strings
  FeatureLink ../languages/strings-feature.html
  Supported ✓
  Example
   "Hello world"
  Token "
 row
  Feature Print() Debugging
  FeatureLink ../languages/print-debugging-feature.html
  Supported ✓
  Example
  Token WriteString
 row
  Feature MultiLine Comments
  FeatureLink ../languages/multiline-comments-feature.html
  Supported ✓
  Example
   (* A comment
   *)
  Token (* *)
 row
  Feature Pointers
  FeatureLink ../languages/pointers-feature.html
  Supported ✓
  Example
  Token 
 row
  Feature Comments
  FeatureLink ../languages/comment-feature.html
  Supported ✓
  Example
  Token 
 row
  Feature Semantic Indentation
  FeatureLink ../languages/semantic-indentation-feature.html
  Supported ϴ
  Example
  Token 
 row
  Feature Operator Overloading
  FeatureLink ../languages/operator-overloading-feature.html
  Supported ϴ
  Example
  Token 
 row
  Feature Line Comments
  FeatureLink ../languages/line-comments-feature.html
  Supported ϴ
  Example
  Token 





foldBreak
subsection Books about Modula-2 from ISBNdb
pipeTable
 title|titleLink|authors|year|publisher
 Programming in Modula-2 (Texts and monographs in computer science)|https://isbndb.com/book/9780387150789|Wirth, Niklaus|1985|Springer-Verlag








keyboardNav nodejs.html tcl.html
