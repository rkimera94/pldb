title Nearley

import settings.scroll
htmlTitle Nearley - Grammar language

viewSourceUrl https://github.com/breck7/pldb/blob/main/database/things/nearley.pldb

paragraph
 Nearley is a <a href="../lists/languages.html?filter=grammarLanguage">grammar language</a> created in <a href="../lists/languages.html?filter=2014">2014</a>.

kpiTable
 #156 <span title="TotalRank: 446 Jobs: 101 Users: 220 Facts: 125 Links: 952">on PLDB</span>
 8 Years Old
 4.1k <span title="Crude user estimate from a linear model.">Users</span>
 0 <span title="Books about or leveraging Nearley">Books</span>
 0 <span title="Academic publications about or leveraging Nearley">Papers</span>
 53 <span title="Nearley repos on GitHub.">Repos</span>







paragraph
 ðŸ“œðŸ”œðŸŒ² Simple, fast, powerful parser toolkit for JavaScript.

list
 - the <a href="https://nearley.js.org/">Nearley website</a>
 - Nearley is developed on <a href="https://github.com/Hardmath123/nearley">GitHub</a> and has 3,231 stars
 - There are at least 53 Nearley repos on <a href="https://github.com/search?q=language:Nearley">GitHub</a>
 - file extensions for Nearley include ne and nearley
 - Nearley is written in <a href="javascript.html">JavaScript</a>
 - The  Google BigQuery Public Dataset GitHub snapshot shows 32 users using Nearley in 33 repos on <a href="https://api.github.com/search/repositories?q=language:Nearley">GitHub</a>
 - GitHub supports <a href="https://github.com/Hardmath123/sublime-nearley" title="The package used for syntax highlighting by GitHub Linguist.">syntax highlighting</a> for Nearley
 - HTML of this page generated by <a href="https://github.com/breck7/pldb/blob/main/code/LanguagePage.ts">LanguagePage.ts</a>
 - <a href="https://build.pldb.com/edit/nearley">Improve our Nearley file</a>

html
 <br>

exampleCodeHeader Example from <a href='https://github.com/Hardmath123/sublime-nearley'>Linguist</a>:
code
 # nearley grammar
 @builtin &quot;string.ne&quot;
 
 @{%
 
 function insensitive(sl) {
     var s = sl.literal;
     result = [];
     for (var i=0; i&lt;s.length; i++) {
         var c = s.charAt(i);
         if (c.toUpperCase() !== c || c.toLowerCase() !== c) {
             result.push(new RegExp(&quot;[&quot; + c.toLowerCase() + c.toUpperCase() + &quot;]&quot;));
         } else {
             result.push({literal: c});
         }
     }
     return {subexpression: [{tokens: result, postprocess: function(d) {return d.join(&quot;&quot;); }}]};
 }
 
 %}
 
 final -&gt; whit? prog whit?  {% function(d) { return d[1]; } %}
 
 prog -&gt; prod  {% function(d) { return [d[0]]; } %}
       | prod whit prog  {% function(d) { return [d[0]].concat(d[2]); } %}
 
 prod -&gt; word whit? (&quot;-&quot;|&quot;=&quot;):+ &quot;&gt;&quot; whit? expression+  {% function(d) { return {name: d[0], rules: d[5]}; } %}
       | word &quot;[&quot; wordlist &quot;]&quot; whit? (&quot;-&quot;|&quot;=&quot;):+ &quot;&gt;&quot; whit? expression+ {% function(d) {return {macro: d[0], args: d[2], exprs: d[8]}} %}
       | &quot;@&quot; whit? js  {% function(d) { return {body: d[2]}; } %}
       | &quot;@&quot; word whit word  {% function(d) { return {config: d[1], value: d[3]}; } %}
       | &quot;@include&quot;  whit? string {% function(d) {return {include: d[2].literal, builtin: false}} %}
       | &quot;@builtin&quot;  whit? string {% function(d) {return {include: d[2].literal, builtin: true }} %}
 
 expression+ -&gt; completeexpression
              | expression+ whit? &quot;|&quot; whit? completeexpression  {% function(d) { return d[0].concat([d[4]]); } %}
 
 expressionlist -&gt; completeexpression
              | expressionlist whit? &quot;,&quot; whit? completeexpression {% function(d) { return d[0].concat([d[4]]); } %}
 
 wordlist -&gt; word
             | wordlist whit? &quot;,&quot; whit? word {% function(d) { return d[0].concat([d[4]]); } %}
 
 completeexpression -&gt; expr  {% function(d) { return {tokens: d[0]}; } %}
                     | expr whit? js  {% function(d) { return {tokens: d[0], postprocess: d[2]}; } %}
 
 expr_member -&gt;
       word {% id %}
     | &quot;$&quot; word {% function(d) {return {mixin: d[1]}} %}
     | word &quot;[&quot; expressionlist &quot;]&quot; {% function(d) {return {macrocall: d[0], args: d[2]}} %} 
     | string &quot;i&quot;:? {% function(d) { if (d[1]) {return insensitive(d[0]); } else {return d[0]; } } %}
     | &quot;%&quot; word {% function(d) {return {token: d[1]}} %}
     | charclass {% id %}
     | &quot;(&quot; whit? expression+ whit? &quot;)&quot; {% function(d) {return {&#39;subexpression&#39;: d[2]} ;} %}
     | expr_member whit? ebnf_modifier {% function(d) {return {&#39;ebnf&#39;: d[0], &#39;modifier&#39;: d[2]}; } %}
 
 ebnf_modifier -&gt; &quot;:+&quot; {% id %} | &quot;:*&quot; {% id %} | &quot;:?&quot; {% id %}
 
 expr -&gt; expr_member
       | expr whit expr_member  {% function(d){ return d[0].concat([d[2]]); } %}
 
 word -&gt; [\w\?\+]  {% function(d){ return d[0]; } %}
       | word [\w\?\+]  {% function(d){ return d[0]+d[1]; } %}
 
 string -&gt; dqstring {% function(d) {return { literal: d[0] }; } %}
 #string -&gt; &quot;\&quot;&quot; charset &quot;\&quot;&quot;  {% function(d) { return { literal: d[1].join(&quot;&quot;) }; } %}
 #
 #charset -&gt; null
 #         | charset char  {% function(d) { return d[0].concat([d[1]]); } %}
 #
 #char -&gt; [^\\&quot;]  {% function(d) { return d[0]; } %}
 #      | &quot;\\&quot; .  {% function(d) { return JSON.parse(&quot;\&quot;&quot;+&quot;\\&quot;+d[1]+&quot;\&quot;&quot;); } %}
 
 charclass -&gt; &quot;.&quot;  {% function(d) { return new RegExp(&quot;.&quot;); } %}
            | &quot;[&quot; charclassmembers &quot;]&quot;  {% function(d) { return new RegExp(&quot;[&quot; + d[1].join(&#39;&#39;) + &quot;]&quot;); } %}
 
 charclassmembers -&gt; null
                   | charclassmembers charclassmember  {% function(d) { return d[0].concat([d[1]]); } %}
 
 charclassmember -&gt; [^\\\]]  {% function(d) { return d[0]; } %}
                  | &quot;\\&quot; .  {% function(d) { return d[0] + d[1]; } %}
 
 js -&gt; &quot;{&quot; &quot;%&quot; jscode &quot;%&quot; &quot;}&quot;  {% function(d) { return d[2]; } %}
 
 jscode -&gt; null  {% function() {return &quot;&quot;;} %}
         | jscode [^%]  {% function(d) {return d[0] + d[1];} %}
         | jscode &quot;%&quot; [^}] {% function(d) {return d[0] + d[1] + d[2]; } %}
 
 # Whitespace with a comment
 whit -&gt; whitraw
       | whitraw? comment whit?
 
 # Optional whitespace with a comment
 whit? -&gt; null
        | whit
 
 # Literally a string of whitespace
 whitraw -&gt; [\s]
          | whitraw [\s]
 
 # A string of whitespace OR the empty string
 whitraw? -&gt; null
           | whitraw
 
 comment -&gt; &quot;#&quot; commentchars &quot;\n&quot;
 commentchars -&gt; null
               | commentchars [^\n]





foldBreak
subsection Language <a href="../lists/features.html">features</a>

treeTable
 row
  Feature Booleans
  FeatureLink ../languages/booleans-feature.html
  Supported âœ“
  Example
  Token true false
 row
  Feature Comments
  FeatureLink ../languages/comment-feature.html
  Supported âœ“
  Example
   # A comment
  Token 
 row
  Feature Line Comments
  FeatureLink ../languages/line-comments-feature.html
  Supported âœ“
  Example
   # A comment
  Token #
 row
  Feature Semantic Indentation
  FeatureLink ../languages/semantic-indentation-feature.html
  Supported Ï´
  Example
  Token 













keyboardNav pl-sql.html idyll.html
