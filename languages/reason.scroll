title Reason

import settings.scroll
htmlTitle Reason - Programming language

viewSourceUrl https://github.com/breck7/pldb/blob/main/database/things/reason.pldb

* Reason is a <a href="../lists/languages.html?filter=pl">programming language</a> created in 2016.
 link ../lists/languages.html?filter=2016 2016

 

kpiTable
 #59 <span title="TotalRank: 213 Jobs: 102 Users: 108 Facts: 3 Links: 486">on PLDB</span>
 6 Years Old
 11.2k <span title="Crude user estimate from a linear model.">Users</span>
 1 <span title="Books about or leveraging Reason">Books</span>
 3 <span title="Academic publications about or leveraging Reason">Papers</span>
 2k <span title="Reason repos on GitHub.">Repos</span>

* Try now: <a href="https://riju.codes/reasonml">Riju</a> Â· <a href="https://tio.run/#reason">TIO</a>

* Simple, fast & type safe code that leverages the JavaScript & OCaml ecosystems

- the <a href="https://reasonml.github.io/">Reason website</a>
- Reason is developed on <a href="https://github.com/facebook/reason">GitHub</a> and has 9,670 stars
- the <a href="https://reasonml.github.io/docs/en/what-and-why">Reason docs</a>
- There are at least 1,924 Reason repos on <a href="https://github.com/search?q=language:Reason">GitHub</a>
- Reason first developed in <a href="../lists/originCommunities.html#Facebook">Facebook</a>
- file extensions for Reason include re and rei
- Reason compiles to <a href="ocaml.html">OCaml</a>
- Reason is written in <a href="ocaml.html">OCaml</a>
- The  Google BigQuery Public Dataset GitHub snapshot shows 23 users using Reason in 24 repos on <a href="https://api.github.com/search/repositories?q=language:Reason">GitHub</a>
- Check out the 11 <a href="https://www.meetup.com/topics/reasonml/">Reason meetup groups</a> on Meetup.com.
- Explore Reason snippets on <a href="http://www.rosettacode.org/wiki/Category:Reason">Rosetta Code</a>
- Here is a Reason <a href="language-server-protocol.html">LSP</a> <a href="https://github.com/jaredly/reason-language-server">implementation</a>
- <a href="languages/pygments.html">Pygments</a> supports <a href="https://github.com/pygments/pygments/blob/master/pygments/lexers/ml.py">syntax highlighting</a> for Reason
- GitHub supports <a href="https://github.com/reasonml-editor/language-reason" title="The package used for syntax highlighting by GitHub Linguist.">syntax highlighting</a> for Reason
- Official Blog page for Reason<a href="https://reasonml.github.io/blog/">(Link)</a>
- See also: (7 related languages)<a href="rust.html">Rust</a>, <a href="elm.html">Elm</a>, <a href="purescript.html">PureScript</a>, <a href="fable-lang.html">Fable</a>, <a href="clojurescript.html">ClojureScript</a>, <a href="swift.html">Swift</a>, <a href="haxe.html">Haxe</a>
- HTML of this page generated by <a href="https://github.com/breck7/pldb/blob/main/code/LanguagePage.ts">LanguagePage.ts</a>
- <a href="https://build.pldb.com/edit/reason">Improve our Reason file</a>

html
 <br>

exampleCodeHeader Example from the web:
code
 type schoolPerson = Teacher | Director | Student(string);
 
 let greeting = person =&gt;
   switch (person) {
   | Teacher =&gt; &quot;Hey Professor!&quot;
   | Director =&gt; &quot;Hello Director.&quot;
   | Student(&quot;Richard&quot;) =&gt; &quot;Still here Ricky?&quot;
   | Student(anyOtherName) =&gt; &quot;Hey, &quot; ++ anyOtherName ++ &quot;.&quot;
   };

exampleCodeHeader Example from <a href='https://riju.codes/reasonml'>Riju</a>:
code
 print_string(&quot;Hello, world!\n&quot;);

exampleCodeHeader Example from <a href='https://github.com/leachim6/hello-world/blob/main/r/Reason.re'>hello-world</a>:
code
 print_string &quot;Hello World&quot;
 

exampleCodeHeader Example from <a href='https://github.com/reasonml-editor/language-reason'>Linguist</a>:
code
 type component = {displayName: string};
 
 let module Bar = {
   let createElement c::c=? children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let module Nesting = {
   let createElement children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let module Much = {
   let createElement children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let module Foo = {
   let createElement a::a=? b::b=? children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let module One = {
   let createElement
       test::test=?
       foo::foo=?
       children =&gt; {
     displayName: &quot;test&quot;
   };
   let createElementobvioustypo
       test::test
       children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let module Two = {
   let createElement foo::foo=? children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let module Sibling = {
   let createElement
       foo::foo=?
       (children: list component) =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let module Test = {
   let createElement yo::yo=? children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let module So = {
   let createElement children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let module Foo2 = {
   let createElement children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let module Text = {
   let createElement children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let module Exp = {
   let createElement children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let module Pun = {
   let createElement intended::intended=? children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let module Namespace = {
   let module Foo = {
     let createElement
         intended::intended=?
         anotherOptional::x=100
         children =&gt; {
       displayName: &quot;test&quot;
     };
   };
 };
 
 let module LotsOfArguments = {
   let createElement
       argument1::argument1=?
       argument2::argument2=?
       argument3::argument3=?
       argument4::argument4=?
       argument5::argument5=?
       argument6::argument6=?
       children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let div argument1::argument1=? children =&gt; {
   displayName: &quot;test&quot;
 };
 
 let module List1 = {
   let createElement children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let module List2 = {
   let createElement children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let module List3 = {
   let createElement children =&gt; {
     displayName: &quot;test&quot;
   };
 };
 
 let (/&gt;&lt;) a b =&gt; a + b;
 
 let (&gt;&lt;) a b =&gt; a + b;
 
 let (/&gt;) a b =&gt; a + b;
 
 let (&gt;&lt;\/) a b =&gt; a + b;
 
 let tag1 = 5 /&gt;&lt; 6;
 
 let tag2 = 5 &gt;&lt; 7;
 
 let tag3 = 5 /&gt; 7;
 
 let tag4 = 5 &gt;&lt;\/ 7;
 
 let b = 2;
 
 let selfClosing = &lt;Foo /&gt;;
 
 let selfClosing2 = &lt;Foo a=1 b=true /&gt;;
 
 let selfClosing3 =
   &lt;Foo
     a=&quot;really long values that should&quot;
     b=&quot;cause the entire thing to wrap&quot;
   /&gt;;
 
 let a = &lt;Foo&gt; &lt;Bar c=(fun a =&gt; a + 2) /&gt; &lt;/Foo&gt;;
 
 let a3 = &lt;So&gt; &lt;Much&gt; &lt;Nesting /&gt; &lt;/Much&gt; &lt;/So&gt;;
 
 let a4 =
   &lt;Sibling&gt;
     &lt;One test=true foo=b /&gt;
     &lt;Two foo=b /&gt;
   &lt;/Sibling&gt;;
 
 let a5 = &lt;Foo&gt; &quot;testing a string here&quot; &lt;/Foo&gt;;
 
 let a6 =
   &lt;Foo2&gt;
     &lt;Text&gt; &quot;testing a string here&quot; &lt;/Text&gt;
     &lt;Test yo=1 /&gt;
     &lt;Text&gt; &quot;another string&quot; &lt;/Text&gt;
     &lt;Bar /&gt;
     &lt;Exp&gt; (2 + 4) &lt;/Exp&gt;
   &lt;/Foo2&gt;;
 
 let intended = true;
 
 let punning = &lt;Pun intended /&gt;;
 
 let namespace = &lt;Namespace.Foo /&gt;;
 
 let c = &lt;Foo /&gt;;
 
 let d = &lt;Foo /&gt;;
 
 let spaceBefore =
   &lt;So&gt; &lt;Much&gt; &lt;Nesting /&gt; &lt;/Much&gt; &lt;/So&gt;;
 
 let spaceBefore2 = &lt;So&gt; &lt;Much /&gt; &lt;/So&gt;;
 
 let siblingNotSpaced =
   &lt;So&gt; &lt;Much /&gt; &lt;Much /&gt; &lt;/So&gt;;
 
 let jsxInList = [&lt;Foo /&gt;];
 
 let jsxInList2 = [&lt;Foo /&gt;];
 
 let jsxInListA = [&lt;Foo /&gt;];
 
 let jsxInListB = [&lt;Foo /&gt;];
 
 let jsxInListC = [&lt;Foo /&gt;];
 
 let jsxInListD = [&lt;Foo /&gt;];
 
 let jsxInList3 = [&lt;Foo /&gt;, &lt;Foo /&gt;, &lt;Foo /&gt;];
 
 let jsxInList4 = [&lt;Foo /&gt;, &lt;Foo /&gt;, &lt;Foo /&gt;];
 
 let jsxInList5 = [&lt;Foo /&gt;, &lt;Foo /&gt;];
 
 let jsxInList6 = [&lt;Foo /&gt;, &lt;Foo /&gt;];
 
 let jsxInList7 = [&lt;Foo /&gt;, &lt;Foo /&gt;];
 
 let jsxInList8 = [&lt;Foo /&gt;, &lt;Foo /&gt;];
 
 let testFunc b =&gt; b;
 
 let jsxInFnCall = testFunc &lt;Foo /&gt;;
 
 let lotsOfArguments =
   &lt;LotsOfArguments
     argument1=1
     argument2=2
     argument3=3
     argument4=4
     argument5=5
     argument6=&quot;test&quot;&gt;
     &lt;Namespace.Foo /&gt;
   &lt;/LotsOfArguments&gt;;
 
 let lowerCase = &lt;div argument1=1 /&gt;;
 
 let b = 0;
 
 let d = 0;
 
 /*
  * Should pun the first example:
  */
 let a = &lt;Foo a&gt; 5 &lt;/Foo&gt;;
 
 let a = &lt;Foo a=b&gt; 5 &lt;/Foo&gt;;
 
 let a = &lt;Foo a=b b=d&gt; 5 &lt;/Foo&gt;;
 
 let a = &lt;Foo a&gt; 0.55 &lt;/Foo&gt;;
 
 let a = Foo.createElement &quot;&quot; [@JSX];
 
 let ident = &lt;Foo&gt; a &lt;/Foo&gt;;
 
 let fragment1 = &lt;&gt; &lt;Foo /&gt; &lt;Foo /&gt; &lt;/&gt;;
 
 let fragment2 = &lt;&gt; &lt;Foo /&gt; &lt;Foo /&gt; &lt;/&gt;;
 
 let fragment3 = &lt;&gt; &lt;Foo /&gt; &lt;Foo /&gt; &lt;/&gt;;
 
 let fragment4 = &lt;&gt; &lt;Foo /&gt; &lt;Foo /&gt; &lt;/&gt;;
 
 let fragment5 = &lt;&gt; &lt;Foo /&gt; &lt;Foo /&gt; &lt;/&gt;;
 
 let fragment6 = &lt;&gt; &lt;Foo /&gt; &lt;Foo /&gt; &lt;/&gt;;
 
 let fragment7 = &lt;&gt; &lt;Foo /&gt; &lt;Foo /&gt; &lt;/&gt;;
 
 let fragment8 = &lt;&gt; &lt;Foo /&gt; &lt;Foo /&gt; &lt;/&gt;;
 
 let fragment9 = &lt;&gt; 2 2 2 2 &lt;/&gt;;
 
 let fragment10 = &lt;&gt; 2.2 3.2 4.6 1.2 &lt;/&gt;;
 
 let fragment11 = &lt;&gt; &quot;str&quot; &lt;/&gt;;
 
 let fragment12 = &lt;&gt; (6 + 2) (6 + 2) (6 + 2) &lt;/&gt;;
 
 let fragment13 = &lt;&gt; fragment11 fragment11 &lt;/&gt;;
 
 let listOfItems1 = &lt;List1&gt; 1 2 3 4 5 &lt;/List1&gt;;
 
 let listOfItems2 =
   &lt;List2&gt; 1.0 2.8 3.8 4.0 5.1 &lt;/List2&gt;;
 
 let listOfItems3 =
   &lt;List3&gt; fragment11 fragment11 &lt;/List3&gt;;
 
 /*
  * Several sequential simple jsx expressions must be separated with a space.
  */
 let thisIsRight a b =&gt; ();
 
 let tagOne children =&gt; ();
 
 let tagTwo children =&gt; ();
 
 /* thisIsWrong &lt;tagOne /&gt;&lt;tagTwo /&gt;; */
 thisIsRight &lt;tagOne /&gt; &lt;tagTwo /&gt;;
 
 /* thisIsWrong &lt;tagOne&gt; &lt;/tagOne&gt;&lt;tagTwo&gt; &lt;/tagTwo&gt;; */
 thisIsRight &lt;tagOne /&gt; &lt;tagTwo /&gt;;
 
 let a children =&gt; ();
 
 let b children =&gt; ();
 
 let thisIsOkay =
   &lt;List1&gt; &lt;a /&gt; &lt;b /&gt; &lt;a /&gt; &lt;b /&gt; &lt;/List1&gt;;
 
 let thisIsAlsoOkay =
   &lt;List1&gt; &lt;a /&gt; &lt;b /&gt; &lt;/List1&gt;;
 
 /* Doesn&#39;t make any sense, but suppose you defined an
    infix operator to compare jsx */
 &lt;a /&gt; &lt; &lt;b /&gt;;
 
 &lt;a /&gt; &gt; &lt;b /&gt;;
 
 &lt;a /&gt; &lt; &lt;b /&gt;;
 
 &lt;a /&gt; &gt; &lt;b /&gt;;
 
 let listOfListOfJsx = [&lt;&gt; &lt;/&gt;];
 
 let listOfListOfJsx = [&lt;&gt; &lt;Foo /&gt; &lt;/&gt;];
 
 let listOfListOfJsx = [
   &lt;&gt; &lt;Foo /&gt; &lt;/&gt;,
   &lt;&gt; &lt;Bar /&gt; &lt;/&gt;
 ];
 
 let listOfListOfJsx = [
   &lt;&gt; &lt;Foo /&gt; &lt;/&gt;,
   &lt;&gt; &lt;Bar /&gt; &lt;/&gt;,
   ...listOfListOfJsx
 ];
 
 let sameButWithSpaces = [&lt;&gt; &lt;/&gt;];
 
 let sameButWithSpaces = [&lt;&gt; &lt;Foo /&gt; &lt;/&gt;];
 
 let sameButWithSpaces = [
   &lt;&gt; &lt;Foo /&gt; &lt;/&gt;,
   &lt;&gt; &lt;Bar /&gt; &lt;/&gt;
 ];
 
 let sameButWithSpaces = [
   &lt;&gt; &lt;Foo /&gt; &lt;/&gt;,
   &lt;&gt; &lt;Bar /&gt; &lt;/&gt;,
   ...sameButWithSpaces
 ];
 
 /*
  * Test named tag right next to an open bracket.
  */
 let listOfJsx = [];
 
 let listOfJsx = [&lt;Foo /&gt;];
 
 let listOfJsx = [&lt;Foo /&gt;, &lt;Bar /&gt;];
 
 let listOfJsx = [&lt;Foo /&gt;, &lt;Bar /&gt;, ...listOfJsx];
 
 let sameButWithSpaces = [];
 
 let sameButWithSpaces = [&lt;Foo /&gt;];
 
 let sameButWithSpaces = [&lt;Foo /&gt;, &lt;Bar /&gt;];
 
 let sameButWithSpaces = [
   &lt;Foo /&gt;,
   &lt;Bar /&gt;,
   ...sameButWithSpaces
 ];
 
 
 /**
  * Test no conflict with polymorphic variant types.
  */
 type thisType = [ | `Foo | `Bar];
 
 type t &#39;a = [&lt; thisType] as &#39;a;
 
 let asd =
   &lt;One test=true foo=2&gt; &quot;a&quot; &quot;b&quot; &lt;/One&gt; [@foo];
 
 let asd2 =
   One.createElementobvioustypo
   test::false
   [&quot;a&quot;, &quot;b&quot;]
   [@JSX]
   [@foo];
 
 let span
     test::(test: bool)
     foo::(foo: int)
     children =&gt; 1;
 
 let asd =
   &lt;span test=true foo=2&gt; &quot;a&quot; &quot;b&quot; &lt;/span&gt; [@foo];
 
 /* &quot;video&quot; call doesn&#39;t end with a list, so the expression isn&#39;t converted to JSX */
 let video test::(test: bool) children =&gt; children;
 
 let asd2 = video test::false 10 [@JSX] [@foo];
 
 let div children =&gt; 1;
 
 ((fun () =&gt; div) ()) [] [@JSX];
 
 let myFun () =&gt;
   &lt;&gt;
     &lt;Namespace.Foo
       intended=true
       anotherOptional=200
     /&gt;
     &lt;Namespace.Foo
       intended=true
       anotherOptional=200
     /&gt;
     &lt;Namespace.Foo
       intended=true anotherOptional=200&gt;
       &lt;Foo /&gt;
       &lt;Foo /&gt;
       &lt;Foo /&gt;
       &lt;Foo /&gt;
       &lt;Foo /&gt;
       &lt;Foo /&gt;
       &lt;Foo /&gt;
     &lt;/Namespace.Foo&gt;
   &lt;/&gt;;
 
 let myFun () =&gt; &lt;&gt; &lt;/&gt;;
 
 let myFun () =&gt;
   &lt;&gt;
     &lt;Namespace.Foo
       intended=true
       anotherOptional=200
     /&gt;
     &lt;Namespace.Foo
       intended=true
       anotherOptional=200
     /&gt;
     &lt;Namespace.Foo
       intended=true anotherOptional=200&gt;
       &lt;Foo /&gt;
       &lt;Foo /&gt;
       &lt;Foo /&gt;
       &lt;Foo /&gt;
       &lt;Foo /&gt;
       &lt;Foo /&gt;
       &lt;Foo /&gt;
     &lt;/Namespace.Foo&gt;
   &lt;/&gt;;
 
 
 /**
  * Children should wrap without forcing attributes to.
  */
 &lt;Foo a=10 b=0&gt;
   &lt;Bar /&gt;
   &lt;Bar /&gt;
   &lt;Bar /&gt;
   &lt;Bar /&gt;
 &lt;/Foo&gt;;
 /**
  * Failing test cases:
  */
 /* let res = &lt;Foo a=10 b=(&lt;Foo a=200 /&gt;) &gt; */
 /*   &lt;Bar /&gt; */
 /* &lt;/Foo&gt;; */
 /* let res = &lt;Foo a=10 b=(&lt;Foo a=200 /&gt;) /&gt;; */
 

## <a href="../lists/keywords.html?filter=reason">Keywords</a> in Reason
* as assert begin class constraint do done downto else end exception external false for fun esfun function functor if in include inherit initializer lazy let switch module pub mutable new nonrec object of open pri rec sig struct then to true try type val virtual when while with

foldBreak
## Language <a href="../lists/features.html">features</a>

treeTable
 row
  Feature Binary Literals
  FeatureLink ../languages/binary-numbers-feature.html
  Supported â
  Example
   // 0[bB][01][01_]*
  Token 
 row
  Feature Integers
  FeatureLink ../languages/integers-feature.html
  Supported â
  Example
   // \d[\d_]*
  Token 
 row
  Feature Floats
  FeatureLink ../languages/floats-feature.html
  Supported â
  Example
   // -?\d[\d_]*(.[\d_]*)?([eE][+\-]?\d[\d_]*)
  Token 
 row
  Feature Hexadecimals
  FeatureLink ../languages/hexadecimals-feature.html
  Supported â
  Example
   // 0[xX][\da-fA-F][\da-fA-F_]*
  Token 
 row
  Feature Octals
  FeatureLink ../languages/octals-feature.html
  Supported â
  Example
   // 0[oO][0-7][0-7_]*
  Token 
 row
  Feature Conditionals
  FeatureLink ../languages/conditionals-feature.html
  Supported â
  Example
  Token 
 row
  Feature Switch Statements
  FeatureLink ../languages/switch-statements-feature.html
  Supported â
  Example
  Token 
 row
  Feature Functions
  FeatureLink ../languages/functions-feature.html
  Supported â
  Example
  Token 
 row
  Feature Classes
  FeatureLink ../languages/classes-feature.html
  Supported â
  Example
  Token 
 row
  Feature While Loops
  FeatureLink ../languages/while-loops-feature.html
  Supported â
  Example
  Token 
 row
  Feature Booleans
  FeatureLink ../languages/booleans-feature.html
  Supported â
  Example
  Token true false
 row
  Feature Strings
  FeatureLink ../languages/strings-feature.html
  Supported â
  Example
   "Hello world"
  Token "
 row
  Feature MultiLine Comments
  FeatureLink ../languages/multiline-comments-feature.html
  Supported â
  Example
   /* A comment
   */
  Token /* */
 row
  Feature Print() Debugging
  FeatureLink ../languages/print-debugging-feature.html
  Supported â
  Example
  Token print_string
 row
  Feature Comments
  FeatureLink ../languages/comment-feature.html
  Supported â
  Example
   // A comment
  Token 
 row
  Feature Destructuring
  FeatureLink ../languages/destructuring-feature.html
  Supported â
  Example
   type person = {name: string, age: int};
   let somePerson = {name: "Guy", age: 30};
   let {name, age} = somePerson;
  Token 
 row
  Feature Line Comments
  FeatureLink ../languages/line-comments-feature.html
  Supported â
  Example
   // A comment
  Token //
 row
  Feature Semantic Indentation
  FeatureLink ../languages/semantic-indentation-feature.html
  Supported Ï´
  Example
  Token 

foldBreak
## Books about Reason from ISBNdb
pipeTable
 title|titleLink|authors|year|publisher
 Fast Guide To Propellerhead Reason|https://isbndb.com/book/9781870775274|Hollin Jones; Debbie Poyser; Derek Johnson|2006|Pc Publishing

foldBreak
## Publications about Reason from Semantic Scholar
pipeTable
 title|titleLink|authors|year|citations|influentialCitations
 Interval propagation to reason about sets: Definition and implementation of a practical language|https://www.semanticscholar.org/paper/6532f8973c4640b8feec743a9937f02ac16f6a38|C. Gervet|1997|177|14
 How to reason with OWL in a logic programming system|https://www.semanticscholar.org/paper/a022506f8daec551f86ec601b1e9e972a86271ee|M. KrÃ¶tzsch and P. Hitzler and Denny VrandeÄiÄ and Michael Sintek|2006|33|1
 Semantic Query Integration With Reason|https://www.semanticscholar.org/paper/7f31fa37c6311d844637ea126e1c47dd5fd387a9|Philipp Seifer and Martin Leinberger and R. LÃ¤mmel and Steffen Staab|2019|6|0

keyboardNav verilog.html basic.html
