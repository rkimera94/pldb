title S-algol

import settings.scroll
htmlTitle S-algol - Programming language

viewSourceUrl https://github.com/breck7/pldb/blob/main/database/things/s-algol.pldb

* S-algol is a <a href="../lists/languages.html?filter=pl">programming language</a> created in 1979.
 link ../lists/languages.html?filter=1979 1979

 

kpiTable
 #282 <span title="TotalRank: 679 Jobs: 101 Users: 1632 Facts: 307 Links: 271">on PLDB</span>
 43 Years Old
 65 <span title="Crude user estimate from a linear model.">Users</span>
 0 <span title="Books about or leveraging S-algol">Books</span>
 0 <span title="Academic publications about or leveraging S-algol">Papers</span>

* S-algol (St Andrews Algol) is a computer programming language derivative of ALGOL 60 developed at the University of St Andrews in 1979 by Ron Morrison and Tony Davie. The language is a modification of ALGOL to contain orthogonal data types that Morrison created for his PhD thesis.  Morrison would go on to become professor at the university and head of the department of computer science. <a href="https://en.wikipedia.org/wiki/S-algol">Read more on Wikipedia...</a>

- the <a href="https://en.wikipedia.org/wiki/S-algol">S-algol Wikipedia page</a>
- S-algol is listed on <a href="https://hopl.info/showlanguage.prx?exp=869">HOPL</a>
- See also: (7 related languages)<a href="algol-60.html">ALGOL 60</a>, <a href="ps-algol.html">PS-algol</a>, <a href="unix.html">Unix</a>, <a href="pascal.html">Pascal</a>, <a href="c.html">C</a>, <a href="napier88.html">Napier88</a>, <a href="algol.html">Algol</a>
- HTML of this page generated by <a href="https://github.com/breck7/pldb/blob/main/code/LanguagePage.ts">LanguagePage.ts</a>
- <a href="https://build.pldb.com/edit/s-algol">Improve our S-algol file</a>

html
 <br>

exampleCodeHeader Example from <a href='https://github.com/leachim6/hello-world/blob/main/s/S Algol'>hello-world</a>:
code
 write &quot;Hello World&quot;
 ?
 

exampleCodeHeader Example from <a href='https://en.wikipedia.org/wiki/S-algol'>Wikipedia</a>:
code
 ! Comments are introduced by an exclamation point and continue until end of line.
 
 ! The let keyword introduces declarations of constants and variables
 ! Identifiers start with an alphabetic character followed by alphanumeric characters or the full stop (.)
 ! An initial value must be given, and this determines the data type of declaration
 
 let width := 10                   ! := sets the value of a variable, this is an int
 let animal := &quot;dog&quot;               ! type string
 
 let x := -7 ; let y := x + x      ! ; separates clauses, needed only if there are two or more clauses on a line
 
 let n.a = 6.022e+23               ! = is used to set the value of a constant, this is a cfloat (constant float)
 
 ! if and case can have values and be used in expressions
 let no.of.lives := if animal = &quot;cat&quot; then 9 else 1
 
 ! Sieve of Eratosthenes
 write &quot;Find primes up to n = ?&quot;
 let n = readi                     ! constant values can be set during the program run
 let p = vector 2::n of true       ! vector of bool with bounds 2 to n
 for i = 2 to truncate(sqrt(n)) do ! for indexes are constants so they use = rather than :=
     if p(i) do                    ! vector dereference uses parens like a procedure call
         for j = 2 * i to n by i do
             p(j) := false
 for i = 2 to n do
     if p(i) do write i, &quot;&#39;n&quot;      ! &#39;n in a literal string is a newline
 
 ! structure (record) type for a binary tree of cstrings
 ! the pntr data type can point to a structure of any type, type checking is done at runtime
 structure tree.node(cstring name ; pntr left, right)
 
 ! inserts a new string into the binary tree head
 procedure insert.tree(cpntr head ; cstring new -&gt; pntr)
 ! the case clause ends with a mandatory default option, use default : {} if it is not needed
 case true of
     head = nil       : tree.node(new, nil, nil)
     new &lt; head(name) : { head(left) := insert.tree(head(left), new) ; head }
     new &gt; head(name) : { head(right) := insert.tree(head(right), new) ; head }
     default          : head
 
 procedure print.tree(cpntr head)
 if head ~= nil do                 ! ~= is the not equals operator
 begin
     print.tree(head(left))
     write head(name), &quot;&#39;n&quot;
     print.tree(head(right))
 end
 
 let fruit := nil
 fruit := insert.tree(fruit, &quot;banana&quot;)
 fruit := insert.tree(fruit, &quot;kiwi&quot;)
 fruit := insert.tree(fruit, &quot;apple&quot;)
 fruit := insert.tree(fruit, &quot;peach&quot;)
 print.tree(fruit)                 ! print in sorted order
 
 ! The end of the S-algol program is indicated by ?
 ?

foldBreak
## Language <a href="../lists/features.html">features</a>

treeTable
 row
  Feature Booleans
  FeatureLink ../languages/booleans-feature.html
  Supported ✓
  Example
  Token true false
 row
  Feature Strings
  FeatureLink ../languages/strings-feature.html
  Supported ✓
  Example
   "Hello world"
  Token "
 row
  Feature Print() Debugging
  FeatureLink ../languages/print-debugging-feature.html
  Supported ✓
  Example
  Token write
 row
  Feature Comments
  FeatureLink ../languages/comment-feature.html
  Supported ✓
  Example
   ! A comment
  Token 
 row
  Feature Line Comments
  FeatureLink ../languages/line-comments-feature.html
  Supported ✓
  Example
   ! A comment
  Token !
 row
  Feature Semantic Indentation
  FeatureLink ../languages/semantic-indentation-feature.html
  Supported ϴ
  Example
  Token 

keyboardNav dns.html factor.html
